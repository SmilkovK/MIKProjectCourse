@{
    ViewData["Title"] = "OOP - Полиморфизам";
}

<body data-topic="polymorphism">
    <div class="container">
        <h1 class="mb-4 text-center">Полиморфизам: Едно име, многу форми</h1>

        <p><strong>Полиморфизам</strong> значи „многу форми“. Во програмирањето, тоа овозможува <strong>исто име на метод</strong> да прави <strong>различни работи</strong> во зависност од контекстот. Тоа е како еден далечински управувач што работи различно за ТВ, клима и светла.</p>

        <p>Полиморфизмот го гледаш постојано во реалниот живот:</p>
        <ul>
            <li><strong>Далечински управувач</strong> со копче Power – вклучува ТВ, менува режим на клима, гаси светла</li>
            <li>Зборот <strong>„банка“</strong> – речно корито, финансиска институција, удар во билијард</li>
            <li><strong>Возач</strong> – вози автомобил, удира топка, забива шајка</li>
            <li><strong>Back копче</strong> на телефонот – се враќа назад, затвора апликација, оди на почетен екран</li>
        </ul>

        <h2 class="text-center">Што е полиморфизам?</h2>
        <p>Полиморфизмот има ДВА главни типа во C#:</p>

        <div class="code-container">
            <div class="code-header">Два типа на полиморфизам</div>
            <div class="code-content">
<pre>
ТИП 1: ПОЛИМОРФИЗАМ ВО ВРЕМЕ НА КОМПИЛАЦИЈА (Статички / Overloading)
────────────────────────────────────────────────────────────────
• ИСТО име на метод, РАЗЛИЧНИ параметри
• Се одлучува при компилација (кога се пишува код)
• Пример: Add(int, int) vs Add(double, double)

ТИП 2: ПОЛИМОРФИЗАМ ВО ВРЕМЕ НА ИЗВРШУВАЊЕ (Динамички / Overriding)
────────────────────────────────────────────────────────────────
• ИСТО име на метод, ИСТИ параметри, РАЗЛИЧНИ класи
• Се одлучува при извршување на програмата
• Пример: Animal.MakeSound() vs Dog.MakeSound()

Размислувај вака:
Overloading = Едно копче, различни влезови
Overriding = Универзално копче што се прилагодува
</pre>
            </div>
        </div>

        <h2 class="text-center">1. Преоптоварување на методи (Compile-Time)</h2>
        <p><strong>Overloading</strong> = Исто име на метод, различни параметри. Компилаторот одлучува која верзија да ја користи.</p>

        <div class="code-container">
            <div class="form-check form-switch mb-2">
                <input class="form-check-input" type="checkbox" id="example1Toggle" onchange="oopPolymorphism.convertCode('example1')">
                <label class="form-check-label" for="example1Toggle">Прикажи напредни примери за overloading</label>
            </div>
            <div class="code-content">
<pre class="codeBlock" id="example1Code">
// Пример: Паметен калкулатор со overloading
public class Calculator
{
    public int Add(int a, int b)
    {
        Console.WriteLine("Собирање цели броеви: " + a + " + " + b);
        return a + b;
    }

    public double Add(double a, double b)
    {
        Console.WriteLine("Собирање децимални броеви: " + a + " + " + b);
        return a + b;
    }

    public int Add(int a, int b, int c)
    {
        Console.WriteLine("Собирање три цели броеви: " + a + " + " + b + " + " + c);
        return a + b + c;
    }

    public int Add(params int[] numbers)
    {
        Console.Write("Собирање низа: ");
        int sum = 0;
        foreach (int num in numbers)
        {
            Console.Write(num + " ");
            sum += num;
        }
        Console.WriteLine();
        return sum;
    }
}

Calculator calc = new Calculator();

int result1 = calc.Add(5, 10);
double result2 = calc.Add(3.5, 2.5);
int result3 = calc.Add(1, 2, 3);
int result4 = calc.Add(1, 2, 3, 4, 5);
</pre>
            </div>
            <div class="result-box" id="example1Result">
                <strong>Излез:</strong><br>
                Собирање цели броеви: 5 + 10<br>
                Собирање децимални броеви: 3.5 + 2.5<br>
                Собирање три цели броеви: 1 + 2 + 3<br>
                Собирање низа: 1 2 3 4 5<br><br>
                Клучна идеја: Го повикуваме истиот метод Add(), но компилаторот избира различна верзија врз основа на параметрите.
            </div>
        </div>

        <h2 class="text-center">2. Препокривање на методи (Runtime Polymorphism)</h2>
        <p><strong>Overriding</strong> = Подкласите дефинираат своја верзија на метод од родителска класа. Се одлучува при извршување.</p>

        <div class="code-container">
            <div class="code-content">
<pre>
// Основна класа
public class Animal
{
    public string Name;

    public virtual void MakeSound()
    {
        Console.WriteLine(Name + " испушта звук.");
    }

    public virtual void Move()
    {
        Console.WriteLine(Name + " се движи.");
    }
}

public class Dog : Animal
{
    public override void MakeSound()
    {
        Console.WriteLine(Name + " вели: Ав! Ав!");
    }
}

public class Cat : Animal
{
    public override void MakeSound()
    {
        Console.WriteLine(Name + " вели: Мјау!");
    }

    public override void Move()
    {
        Console.WriteLine(Name + " оди елегантно.");
    }
}

Animal pet1 = new Dog { Name = "Buddy" };
Animal pet2 = new Cat { Name = "Whiskers" };

pet1.MakeSound();
pet2.MakeSound();
pet2.Move();
</pre>
            </div>
            <div class="result-box">
                <strong>Излез:</strong><br>
                Buddy вели: Ав! Ав!<br>
                Whiskers вели: Мјау!<br>
                Whiskers оди елегантно.<br><br>
                Иако променливите се од тип Animal, се повикува точниот метод според реалниот објект.
            </div>
        </div>

        <h2 class="text-center">Клучни зборови: virtual и override</h2>
        <div class="code-container">
            <div class="code-content">
<pre>
virtual  – дозволува методот да биде препокриен
override – ја заменува имплементацијата од родителската класа
base     – повикува метод од родителската класа
sealed   – спречува понатамошно препокривање
</pre>
            </div>
        </div>

        <h2 class="text-center">Кога да користиш полиморфизам?</h2>
        <div class="code-container">
            <div class="code-content">
<pre>
КОРИСТИ OVERLOADING КОГА:
- Истата операција има различни влезни податоци
- Сакаш пофлексибилен и почитлив код

КОРИСТИ OVERRIDING КОГА:
- Различни класи имаат различно однесување
- Работиш со наследување
- Градиш проширливи системи

ПРИМЕРИ:
- Shape.Draw() → Circle.Draw(), Rectangle.Draw()
- Payment.Process() → Card, PayPal, Crypto
- GameCharacter.Attack() → Warrior, Mage
</pre>
            </div>
        </div>

        <h2 class="text-center">Резиме: Моќта на полиморфизмот</h2>
        <ul>
            <li>Полиморфизам = ист интерфејс, различно однесување</li>
            <li>Overloading – флексибилност при компилација</li>
            <li>Overriding – прилагодување при извршување</li>
            <li>Овозможува чист, одржлив и проширлив код</li>
        </ul>

        <div class="navigation-buttons">
            <a href="@Url.Action("Encapsulation", "OOP")" class="btn btn-outline-primary ajax-link">← Инкапсулација</a>
            <a href="@Url.Action("Abstraction", "OOP")" class="btn btn-primary ajax-link">Апстракција →</a>
        </div>
    </div>



<style>
    .container {
        max-width: 800px;
        padding: 20px;
        background-color: var(--bs-body-bg);
    }

    h1, h2, h3 {
        color: var(--bs-heading-color);
        margin-bottom: 15px;
    }

    h1 {
        border-bottom: 2px solid var(--bs-primary);
        padding-bottom: 10px;
    }

    p, li, code {
        color: var(--bs-body-color);
        line-height: 1.6;
    }

    .code-container {
        margin: 25px 0;
        border: 1px solid var(--bs-border-color);
        border-radius: 5px;
        overflow: hidden;
        background-color: var(--code-bg);
    }

    .code-header {
        background-color: var(--code-header-bg);
        padding: 10px 15px;
        border-bottom: 1px solid var(--bs-border-color);
        font-family: 'SFMono-Regular', Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        font-size: 0.9rem;
        color: var(--bs-body-color);
    }

    .code-content {
        padding: 15px;
        overflow-x: auto;
    }

    pre {
        margin: 0;
        white-space: pre-wrap;
        background-color: transparent;
        font-family: 'SFMono-Regular', Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    .result-box {
        padding: 10px 15px;
        background-color: rgba(0, 123, 255, 0.1);
        border-top: 1px solid var(--bs-border-color);
        font-size: 0.95rem;
    }

    .navigation-buttons {
        display: flex;
        justify-content: space-between;
        margin-top: 30px;
    }

    .btn {
        padding: 8px 20px;
        border-radius: 4px;
        font-weight: 500;
        text-decoration: none;
    }

    .btn-primary {
        background-color: var(--bs-primary);
        border-color: var(--bs-primary);
        color: #fff;
    }

    .btn-outline-primary {
        color: var(--bs-primary);
        border-color: var(--bs-primary);
        background-color: transparent;
    }

    .text-center {
        text-align: center;
    }

    .correct-text {
        color: var(--bs-success);
        font-weight: 500;
    }

    .error-text {
        color: var(--bs-danger);
        font-weight: 500;
    }
</style>

    <script>
            // Креирање namespace за OOP Polymorphism страница
            window.oopPolymorphism = {
                // Интерактивен walkthrough за overloading
                overloadSteps: [
                    {
                        code: `public class Printer
        {
            public void Print(string text)
            {
                Console.WriteLine("Printing text: " + text);
            }

            public void Print(int number)
            {
                Console.WriteLine("Printing number: " + number);
            }

            public void Print(string text, int copies)
            {
                Console.WriteLine("Printing '" + text + "' " + copies + " times");
            }
        }

        // Printer printer = new Printer();
        // printer.Print("Hello");
        // printer.Print(42);
        // printer.Print("Test", 3);`,
                        vars: `Printer class defined with 3 overloaded Print methods:
        1. Print(string text)
        2. Print(int number)
        3. Print(string text, int copies)

        No printer object created yet.`,
                        exp: "We define a Printer class with THREE Print methods. All have the same name but different parameters. This is method overloading - same name, different 'signatures'."
                    },
                    {
                        code: `public class Printer
        {
            public void Print(string text)
            {
                Console.WriteLine("Printing text: " + text);
            }

            public void Print(int number)
            {
                Console.WriteLine("Printing number: " + number);
            }

            public void Print(string text, int copies)
            {
                Console.WriteLine("Printing '" + text + "' " + copies + " times");
            }
        }

        Printer printer = new Printer();
        // printer.Print("Hello");
        // printer.Print(42);
        // printer.Print("Test", 3);`,
                        vars: `Printer object created.
        Can call any of the 3 Print methods.
        Compiler will decide which one based on parameters.`,
                        exp: "We create a Printer object. The compiler now knows about all three Print methods. When we call Print(), it will look at what parameters we provide to decide which version to use."
                    },
                    {
                        code: `public class Printer
        {
            public void Print(string text)
            {
                Console.WriteLine("Printing text: " + text);
            }

            public void Print(int number)
            {
                Console.WriteLine("Printing number: " + number);
            }

            public void Print(string text, int copies)
            {
                Console.WriteLine("Printing '" + text + "' " + copies + " times");
            }
        }

        Printer printer = new Printer();
        printer.Print("Hello");  // Повикување со string
        // printer.Print(42);
        // printer.Print("Test", 3);`,
                        vars: `Calling: printer.Print("Hello")
        Compiler checks:
        - Parameter type: string
        - Looks for Print(string) → FOUND!
        Calls: Print(string text) version

        Output: "Printing text: Hello"`,
                        exp: "We call Print(\"Hello\"). The compiler sees we're passing a string. It looks through the overloaded methods and finds Print(string text) matches perfectly. This happens at COMPILE time."
                    },
                    {
                        code: `public class Printer
        {
            public void Print(string text)
            {
                Console.WriteLine("Printing text: " + text);
            }

            public void Print(int number)
            {
                Console.WriteLine("Printing number: " + number);
            }

            public void Print(string text, int copies)
            {
                Console.WriteLine("Printing '" + text + "' " + copies + " times");
            }
        }

        Printer printer = new Printer();
        printer.Print("Hello");
        printer.Print(42);  // Повикување со int
        // printer.Print("Test", 3);`,
                        vars: `Calling: printer.Print(42)
        Compiler checks:
        - Parameter type: int
        - Looks for Print(int) → FOUND!
        Calls: Print(int number) version

        Output: "Printing number: 42"`,
                        exp: "We call Print(42). The compiler sees an int parameter. It finds Print(int number) matches. Different parameter type = different method called, even though they have the same name!"
                    },
                    {
                        code: `public class Printer
        {
            public void Print(string text)
            {
                Console.WriteLine("Printing text: " + text);
            }

            public void Print(int number)
            {
                Console.WriteLine("Printing number: " + number);
            }

            public void Print(string text, int copies)
            {
                Console.WriteLine("Printing '" + text + "' " + copies + " times");
            }
        }

        Printer printer = new Printer();
        printer.Print("Hello");
        printer.Print(42);
        printer.Print("Test", 3);  // Повикување со string И int`,
                        vars: `Calling: printer.Print("Test", 3)
        Compiler checks:
        - Parameters: string, int
        - Looks for Print(string, int) → FOUND!
        Calls: Print(string text, int copies) version

        Output: "Printing 'Test' 3 times"`,
                        exp: "We call Print(\"Test\", 3). The compiler sees string AND int parameters. It finds Print(string text, int copies) matches. Three calls, same method name, three different outputs - that's overloading!"
                    }
                ],

                // Примери на код за toggle копчињата
                simpleExamples: {
                    example1: `// Пример: Паметен калкулатор со overloading
        public class Calculator
        {
            // Верзија 1: Собира два цели броја
            public int Add(int a, int b)
            {
                Console.WriteLine("Adding integers: " + a + " + " + b);
                return a + b;
            }

            // Верзија 2: Собира два double броја
            public double Add(double a, double b)
            {
                Console.WriteLine("Adding doubles: " + a + " + " + b);
                return a + b;
            }

            // Верзија 3: Собира три цели броја
            public int Add(int a, int b, int c)
            {
                Console.WriteLine("Adding three integers: " + a + " + " + b + " + " + c);
                return a + b + c;
            }
        }`,
                    example2: `// Основна класа со virtual метод
        public class Animal
        {
            public string Name;

            // Virtual метод - може да се override
            public virtual void MakeSound()
            {
                Console.WriteLine(Name + " makes a generic animal sound.");
            }
        }

        // Child класа Dog - го override MakeSound
        public class Dog : Animal
        {
            public override void MakeSound()
            {
                Console.WriteLine(Name + " says: Woof! Woof!");
            }
        }

        // Child класа Cat - го override MakeSound
        public class Cat : Animal
        {
            public override void MakeSound()
            {
                Console.WriteLine(Name + " says: Meow!");
            }
        }

        // Child класа Bird - го override MakeSound
        public class Bird : Animal
        {
            public override void MakeSound()
            {
                Console.WriteLine(Name + " says: Tweet! Tweet!");
            }
        }`
                },

                // Комплетни примери
                completeExamples: {
                    example1: `// Пример: Паметен калкулатор со overloading
        public class Calculator
        {
            // Верзија 1: Собира два цели броја
            public int Add(int a, int b)
            {
                Console.WriteLine("Adding integers: " + a + " + " + b);
                return a + b;
            }

            // Верзија 2: Собира два double броја (различен тип на параметри)
            public double Add(double a, double b)
            {
                Console.WriteLine("Adding doubles: " + a + " + " + b);
                return a + b;
            }

            // Верзија 3: Собира три цели броја (различен број на параметри)
            public int Add(int a, int b, int c)
            {
                Console.WriteLine("Adding three integers: " + a + " + " + b + " + " + c);
                return a + b + c;
            }

            // Верзија 4: Собира низа од цели броја
            public int Add(params int[] numbers)
            {
                Console.Write("Adding array: ");
                int sum = 0;
                foreach (int num in numbers)
                {
                    Console.Write(num + " ");
                    sum += num;
                }
                Console.WriteLine();
                return sum;
            }
        }

        // Користење на overloaded методите
        Calculator calc = new Calculator();

        // Компилаторот знае КОЈ Add() да го повика според параметрите
        int result1 = calc.Add(5, 10);
        double result2 = calc.Add(3.5, 2.5);
        int result3 = calc.Add(1, 2, 3);
        int result4 = calc.Add(1, 2, 3, 4, 5);`,
                    example2: `// Основна класа со virtual метод
        public class Animal
        {
            public string Name;

            // Virtual метод - може да биде override од деца
            public virtual void MakeSound()
            {
                Console.WriteLine(Name + " makes a generic animal sound.");
            }

            // Virtual метод со default однесување
            public virtual void Move()
            {
                Console.WriteLine(Name + " moves in some way.");
            }
        }

        // Child класа Dog - го override MakeSound
        public class Dog : Animal
        {
            // override keyword - дава Dog верзија
            public override void MakeSound()
            {
                Console.WriteLine(Name + " says: Woof! Woof!");
            }

            // Dog НЕ го override Move() - ја користи Animal верзијата
        }

        // Child класа Cat - го override MakeSound
        public class Cat : Animal
        {
            public override void MakeSound()
            {
                Console.WriteLine(Name + " says: Meow!");
            }

            // Cat го override и Move()
            public override void Move()
            {
                Console.WriteLine(Name + " walks gracefully.");
            }
        }

        // Child класа Bird - ги override двата методи
        public class Bird : Animal
        {
            public override void MakeSound()
            {
                Console.WriteLine(Name + " says: Tweet! Tweet!");
            }

            public override void Move()
            {
                Console.WriteLine(Name + " flies through the air.");
            }
        }`
                },

                currentStep: 0,

                // Функција за конверзија помеѓу simple и complete верзија
                convertCode: function(id) {
                    const toggle = document.getElementById(id + "Toggle");
                    const isComplete = toggle ? toggle.checked : false;
                    const codeBlock = document.getElementById(id + "Code");
                    const resultBox = document.getElementById(id + "Result");

                    if (codeBlock && toggle) {
                        codeBlock.style.transition = 'opacity 0.3s ease';
                        codeBlock.style.opacity = '0.5';
                        setTimeout(() => {
                            codeBlock.textContent = isComplete ? this.completeExamples[id] : this.simpleExamples[id];
                            codeBlock.style.opacity = '1';
                        }, 300);
                    }
                },

                // Функција за ажурирање на walkthrough приказот
                updateWalkthrough: function(step) {
                    const walkthroughCodeBase = document.getElementById('walkthroughCodeBase');
                    const walkthroughVariables = document.getElementById('walkthroughVariables');
                    const walkthroughExplanation = document.getElementById('walkthroughExplanation');
                    const nextStepBtn = document.getElementById('nextStepBtn');

                    if (!walkthroughCodeBase || !walkthroughVariables || !walkthroughExplanation) return;

                    const data = this.overloadSteps[step];

                    walkthroughCodeBase.textContent = data.code;
                    walkthroughVariables.textContent = data.vars;
                    walkthroughExplanation.innerHTML = `<em>Step ${step + 1}:</em> ${data.exp}`;

                    if (step === this.overloadSteps.length - 1 && nextStepBtn) {
                        walkthroughExplanation.innerHTML += '<br><strong>Complete! Overloading lets one method name handle different parameter combinations.</strong>';
                        nextStepBtn.disabled = true;
                    }
                },

                nextStep: function() {
                    if (this.currentStep < this.overloadSteps.length) {
                        this.updateWalkthrough(this.currentStep);
                        this.currentStep++;
                    }
                },

                initWalkthrough: function() {
                    const nextStepBtn = document.getElementById('nextStepBtn');
                    if (nextStepBtn) {
                        this.currentStep = 0;

                        const newButton = nextStepBtn.cloneNode(true);
                        nextStepBtn.parentNode.replaceChild(newButton, nextStepBtn);

                        newButton.addEventListener('click', () => this.nextStep());
                        newButton.disabled = false;

                        this.updateWalkthrough(0);
                        this.currentStep = 1;
                    }
                },

                initCodeExamples: function() {
                    const toggles = document.querySelectorAll('.form-check-input[type="checkbox"]');
                    toggles.forEach(toggle => {
                        const id = toggle.id.replace('Toggle', '');
                        if (id && this.simpleExamples[id]) {
                            this.convertCode(id);
                            toggle.addEventListener('change', () => this.convertCode(id));
                        }
                    });
                },

                init: function() {
                    console.log('Initializing OOP Polymorphism page');
                    this.initCodeExamples();
                    this.initWalkthrough();

                    if (typeof hljs !== 'undefined') {
                        hljs.highlightAll();
                    }
                }
            };

            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', () => {
                    window.oopPolymorphism.init();
                });
            } else {
                window.oopPolymorphism.init();
            }
    </script>

</body>