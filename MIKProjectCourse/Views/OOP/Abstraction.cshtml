@{
    ViewData["Title"] = "OOP - Апстракција";
}

<body data-topic="abstraction">
    <div class="container">
        <h1 class="mb-4">Апстракција: Скривање на комплексност, прикажување на едноставност</h1>

        <p><strong>Апстракција</strong> е како користење на <strong>TV далечински управувач</strong> - притискате копчиња за да менувате канали или да ја регулирате јачината на звукот без да знаете за електронските кола внатре. Во програмирањето, апстракцијата ја крие комплексноста и покажува само она што е потребно.</p>

        <p>Апстракција користите во секојдневниот живот:</p>
        <ul>
            <li><strong>Контрола на автомобилот</strong> - покажува брзина, ниво на гориво, но ја крие комплексноста на моторот</li>
            <li><strong>Смартфон</strong> - тапкате на апликации, но не гледате милиони линии код</li>
            <li><strong>ATM машина</strong> - добивате пари без да знаете детали за банкарскиот софтвер</li>
            <li><strong>Микробранова</strong> - поставувате време, но не гледате како се генерира зрачење</li>
        </ul>

        <h2>Што е Апстракција?</h2>
        <p>Апстракцијата има ДВА главни алатки во C#:</p>

        <div class="code-container">
            <div class="code-header">Две алатки за апстракција</div>
            <div class="code-content">
<pre>
АЛАТКА 1: АБСТРАКТНИ КЛАСИ
────────────────────────
• МОЖЕ да има делумна имплементација (некои методи имаат код)
• МОЖЕ да има апстрактни методи (нема код, мора да се имплементира)
• Пример: Класа Vehicle со делумен код + апстрактен Drive()

АЛАТКА 2: ИНТЕРФЕЈСИ
────────────────────────
• НЕ МОЖЕ да има имплементација (само сигнатури на методи)
• Чист договор, без код
• Пример: IDrivable со сигнатури Drive(), Stop()

И ДВЕТО:
• Не може да се создадат објекти директно (не може: new AbstractClass())
• Се принудуваат наследниците да имплементираат одредени методи
• Се крие комплексноста зад едноставни интерфејси

Смислете го вака:
Апстрактна класа = Рецепт со делумно пополнети чекори
Интерфејс = Листа на потребни состојки
</pre>
            </div>
        </div>

        <h2>1. Апстрактни класи (Делумна апстракција)</h2>
        <p>Апстрактните класи можат да имаат ИМПЛЕМЕНТИРАНИ и АПСТРАКТНИ методи:</p>

        <div class="code-container">
            <div class="form-check form-switch mb-2">
                <input class="form-check-input" type="checkbox" id="example1Toggle" onchange="oopAbstraction.convertCode('example1')">
                <label class="form-check-label" for="example1Toggle">Прикажи цел систем на облици</label>
            </div>
            <div class="code-content">
<pre class="codeBlock" id="example1Code">
// Апстрактна класа: Дефинира што се облиците, делумно како
public abstract class Shape
{
    // Апстрактен метод - МОРАТ да го имплементираат наследниците
    public abstract double CalculateArea();

    // Апстрактен метод - МОРАТ да го имплементираат
    public abstract double CalculatePerimeter();

    // Конкретен метод - веќе имплементиран
    public void DisplayInfo()
    {
        Console.WriteLine("Тип на облик: " + GetType().Name);
        Console.WriteLine("Плоштина: " + CalculateArea());
        Console.WriteLine("Периметар: " + CalculatePerimeter());
        Console.WriteLine("---");
    }

    // Друг конкретен метод
    public virtual string GetDescription()
    {
        return "Ова е геометриски облик.";
    }
}

// Конкретна класа: Circle ја имплементира Shape
public class Circle : Shape
{
    public double Radius;

    // МОРАТ да имплементираат апстрактни методи
    public override double CalculateArea()
    {
        return Math.PI * Radius * Radius;
    }

    public override double CalculatePerimeter()
    {
        return 2 * Math.PI * Radius;
    }

    // МОЖЕ да ја надополните виртуелната метода (опционално)
    public override string GetDescription()
    {
        return "Круг со радиус " + Radius;
    }
}

// Конкретна класа: Rectangle ја имплементира Shape
public class Rectangle : Shape
{
    public double Width;
    public double Height;

    public override double CalculateArea()
    {
        return Width * Height;
    }

    public override double CalculatePerimeter()
    {
        return 2 * (Width + Height);
    }

    // Го користи стандардниот GetDescription() од Shape
}

// Конкретна класа: Triangle ја имплементира Shape
public class Triangle : Shape
{
    public double Base;
    public double Height;
    public double SideA;
    public double SideB;
    public double SideC;

    public override double CalculateArea()
    {
        return 0.5 * Base * Height;
    }

    public override double CalculatePerimeter()
    {
        return SideA + SideB + SideC;
    }

    public override string GetDescription()
    {
        return "Триаголник со основа " + Base + " и висина " + Height;
    }
}

// Користење на апстракцијата
Console.WriteLine("=== Пресметки на облици ===");

// Не може да се создаде Shape директно
// Но може да се чуваат објекти на деца во Shape променливи

Shape circle = new Circle() { Radius = 5 };
Shape rectangle = new Rectangle() { Width = 4, Height = 6 };
Shape triangle = new Triangle() { Base = 3, Height = 4, SideA = 3, SideB = 4, SideC = 5 };

// Исти повици на методи, различни имплементации
circle.DisplayInfo();      
rectangle.DisplayInfo();   
triangle.DisplayInfo();    

// Сите облици имаат GetDescription() од Shape класа
Console.WriteLine("Описи:");
Console.WriteLine(circle.GetDescription());
Console.WriteLine(rectangle.GetDescription());  
Console.WriteLine(triangle.GetDescription());
</pre>
            </div>
            <div class="result-box" id="example1Result">
                <strong>Излез:</strong><br>
                === Пресметки на облици ===<br>
                Тип на облик: Circle<br>
                Плоштина: 78.53981633974483<br>
                Периметар: 31.41592653589793<br>
                ---<br>
                Тип на облик: Rectangle<br>
                Плоштина: 24<br>
                Периметар: 20<br>
                ---<br>
                Тип на облик: Triangle<br>
                Плоштина: 6<br>
                Периметар: 12<br>
                ---<br><br>
                Описи:<br>
                Круг со радиус 5<br>
                Ова е геометриски облик.<br>
                Триаголник со основа 3 и висина 4<br><br>
                <em>Апстракција во акција:</em> Shape класата го крие КАКО се пресметува плоштината и периметарот. Circle, Rectangle и Triangle ја имплементираат својата формула. Корисниците само повикуваат CalculateArea() без да знаат математика.
            </div>
        </div>

        <h2>Интерактивен преглед: Како функционира апстракцијата</h2>
        <p>Следете ја апстракцијата чекор по чекор:</p>

        <div class="code-container">
            <div class="code-header">Апстракциски слоеви</div>
            <div class="code-content">
<pre>
public abstract class PaymentProcessor
{
    // Апстрактно - наследниците мора да го имплементираат
    public abstract bool Process(decimal amount);

    // Конкретно - веќе имплементирано  
    public void PrintReceipt(decimal amount)
    {
        Console.WriteLine("Доказ за: $" + amount);
        Console.WriteLine("Датум: " + DateTime.Now);
    }

    // Виртуелно - може да се надополнува
    public virtual string GetProcessorName()
    {
        return "Општ обработувач на плаќања";
    }
}
</pre>
            </div>
        </div>

        <div class="code-container">
            <div class="code-header">Нивоа на апстракција</div>
            <div class="code-content">
<pre>
PaymentProcessor (Апстрактна класа):
- Process() метод: АПСТРАКТЕН (нема имплементација)
- PrintReceipt() метод: КОНКРЕТЕН (има имплементација)
- GetProcessorName() метод: ВИРТУЕЛЕН (има стандард, може да се надополни)

Наследничките класи добиваат PrintReceipt() бесплатно, мора да го имплементираат Process().
</pre>
            </div>
            <div class="result-box" id="walkthroughExplanation">
                <em>Кликнете Next за да ја видите апстракцијата чекор по чекор:</em>
            </div>
            <button class="btn btn-primary mt-2" id="nextStepBtn">Next →</button>
        </div>

        <h2>Визуелна дијаграма: Слоеви на апстракција</h2>

        <div class="code-container">
            <div class="code-header">Како апстракцијата ја крие комплексноста</div>
            <div class="code-content">
<pre>
Поглед на корисникот (Едноставен интерфејс):
─────────────────────────────────────────────
Shape shape = new Circle(5);
double area = shape.CalculateArea();  
shape.DisplayInfo();                   

Корисникот не гледа (Скриена комплексност):
─────────────────────────────────────────────
АПСТРАКТНА КЛАСА:
public abstract class Shape
{
    public abstract double CalculateArea();  // Мора да се имплементира
    public void DisplayInfo() { ... }       // Еве некој стандард код
}

КОНКРЕТНА ИМПЛЕМЕНТАЦИЈА:
public class Circle : Shape
{
    private double radius;
    private const double PI = 3.14159265358979;

    public override double CalculateArea()
    {
        // Комплексна математика скриена од корисник
        return PI * radius * radius;
    }
}

public class Rectangle : Shape
{
    private double width, height;

    public override double CalculateArea()
    {
        // Различна математика, исто скриена
        return width * height;
    }
}

БЕНЕФИТ ОД АПСТРАКЦИЈА:
─────────────────────────────────────────────
Кориснички код:                          |   Скриена комплексност:
─────────────────────────────────────────────
Shape s = GetShape();                     |   Circle: πr²
double a = s.CalculateArea();             |   Rectangle: w×h
                                          |   Triangle: ½bh
                                          |   Pentagon: комплексна формула
                                          |
ЕДНОСТАВЕН ИНТЕРФЕЈС                      |   КОМПЛЕКСНИ ИМПЛЕМЕНТАЦИИ
(исто за сите облици)                     |   (различно за секој облик)
</pre>
            </div>
        </div>

        <h2>Пример 2: Апстракција за база на податоци</h2>
        <p>Апстрактните класи се идеални за операции со база на податоци - исти интерфејс, различни бази:</p>

        <div class="code-container">
            <div class="code-header">Апстракција на конекција со база</div>
            <div class="code-content">
<pre>
public abstract class DatabaseConnection
{
    public abstract void Connect();
    public abstract void Disconnect();
    public abstract void ExecuteQuery(string query);

    public void LogOperation(string operation)
    {
        Console.WriteLine($"[{DateTime.Now}] {operation}");
    }

    public virtual int GetTimeout()
    {
        return 30;  
    }

    public abstract string ConnectionString { get; set; }
}

public class SqlServerConnection : DatabaseConnection
{
    private string connectionString;

    public override string ConnectionString
    {
        get { return connectionString; }
        set { connectionString = value; }
    }

    public override void Connect()
    {
        LogOperation("Поврзување со SQL Server...");
        Console.WriteLine("Конекција со SQL Server воспоставена.");
    }

    public override void Disconnect()
    {
        LogOperation("Одврзување од SQL Server...");
        Console.WriteLine("Конекција со SQL Server затворена.");
    }

    public override void ExecuteQuery(string query)
    {
        LogOperation("Извршување на SQL query: " + query);
        Console.WriteLine("Query извршен на SQL Server.");
    }

    public override int GetTimeout()
    {
        return 60;  
    }
}

public class MySqlConnection : DatabaseConnection
{
    private string connectionString;

    public override string ConnectionString
    {
        get { return connectionString; }
        set { connectionString = value; }
    }

    public override void Connect()
    {
        LogOperation("Поврзување со MySQL...");
        Console.WriteLine("Конекција со MySQL воспоставена.");
    }

    public override void Disconnect()
    {
        LogOperation("Одврзување од MySQL...");
        Console.WriteLine("Конекција со MySQL затворена.");
    }

    public override void ExecuteQuery(string query)
    {
        LogOperation("Извршување на MySQL query: " + query);
        Console.WriteLine("Query извршен на MySQL.");
    }
}
</pre>
            </div>
        </div>

        <h2>Апстрактна vs Конкретна класа</h2>
        <div class="code-container">
            <div class="code-header">Клучни разлики</div>
            <div class="code-content">
<pre>
                  АПСТРАКТНА КЛАСА           КОНКРЕТНА КЛАСА
─────────────────────────────────────────────────────────────
Иницијализација   НЕ МОЖЕ да се создадат објекти     МОЖЕ да се создадат објекти
                <span style="color:red;">// Некој пример на ❌ претходно</span> new Shape()            
                <span style="color:green;">// Некој пример на ✅ претходно</span> new Circle()

Имплементација    Може да има И ДВЕТО:               Мора да има ПОЛНА:
                  • Апстрактни методи               • Сите методи имплементирани
                  • Конкретни методи                • Без апстрактни методи
                  • Виртуелни методи

Цел               • Дефинира основна структура      • Подготвени за употреба објекти
                  • Принудува имплементација       • Комплетна функционалност
                  • Споделува заеднички код        • Специфично однесување

Наследување       Се користи за наследување         Може да се наследи или самостојно
                  (основна класа)                   (може да биде база или лист)

Пример            Shape (апстрактна)               Circle, Rectangle, Triangle
                  • CalculateArea() апстрактен      • Circle.CalculateArea() = πr²
                  • DisplayInfo() конкретен         • Rectangle.CalculateArea() = w×h

Реална аналогија  Прирачник за вработените         Вистински вработен
                  (некои правила, некои празнини) (врши вистинска работа)

Кога да се користи • Креирање на рамки           • Креирање објекти
                  • Дефинирање договори          • Имплементирање логика
                  • Споделување код               • Финална имплементација
                  • Кога повеќе поврзани класи делат однесување
</pre>
            </div>
        </div>

        <h2>Чести грешки при апстракција</h2>
        <div class="code-container">
            <div class="code-header">Проблеми со апстракција</div>
            <div class="code-content">
<pre>
// <span style="color:red;">Мистерија 1</span>: Апстрактна класа без апстрактни членови
public abstract class Logger
{
    public void Log(string message)  
    {
        Console.WriteLine(message);
    }
    // Не може да принуди имплементација
}

// <span style="color:green;">Решение</span>: Користете апстракција кога е потребно
public abstract class Logger
{
    public abstract void Log(string message);  
    public virtual string GetSource() { return "Unknown"; }  
}

// <span style="color:red;">Мистерија 2</span>: Заборавено имплементирање апстрактни методи
public abstract class Animal
{
    public abstract void MakeSound();
}

public class Dog : Animal
{
    // Ошибка - COMPILER ERROR!
}

// <span style="color:green;">Решение</span>: Имплементирајте сите апстрактни методи
public class Dog : Animal
{
    public override void MakeSound()  
    {
        Console.WriteLine("Woof!");
    }
}
</pre>
            </div>
        </div>

        <h2>Кога да се користи апстракција</h2>
        <div class="code-container">
            <div class="code-header">Упатства</div>
            <div class="code-content">
<pre>
Користете апстрактни класи кога:
- Потребно е да се сподели код меѓу поврзани класи
- Постојат основни имплементации со варијации
- Се нуди стандардно однесување кое може да се надополни
- Креирате рамки или бази на библиотеки

Користете интерфејси кога:
- Потребен е чист договор без имплементација
- Неповрзани класи имаат исти способности
- Потребна е мулти-наследност
- Дефинирање на plugin/extensibility точки

Не користете апстракција кога:
- Класата е комплетна и спремна за употреба
- Постоји само една имплементација
- Апстракцијата не поедноставува ништо
- Создавате едноставни контејнери на податоци
</pre>
            </div>
        </div>

        <h2>Поврзаност со други OOP концепти</h2>
        <div class="code-container">
            <div class="code-header">Како апстракцијата се поврзува</div>
            <div class="code-content">
<pre>
АПСТРАКЦИЈА + НАСЛЕДУВАЊЕ:
- Апстрактните класи се наследуваат
- Принудува имплементација на апстрактни методи
- Наследниците добиваат конкретни методи бесплатно

АПСТРАКЦИЈА + ЕНКАПСУЛАЦИЈА:
- Апстракцијата крие комплексност
- Енкапсулацијата ја штити податоците
- Корисникот повикува Connect() без да знае детали

АПСТРАКЦИЈА + ПОЛИМОРФИЗАМ:
- Апстракцијата дефинира интерфејс
- Полиморфизмот обезбедува имплементации
- Исти повици на методи, различно однесување

АПСТРАКЦИЈА + ИНТЕРФЕЈСИ:
- Двете обезбедуваат апстракција, но различно
- Апстрактна класа: може имплементација, единствено наследување, конструктори дозволени
- Интерфејс: нема имплементација, мулти-интерфејс, без конструктори
</pre>
            </div>
        </div>

        <h2>Резиме: Моќта на апстракцијата</h2>
        <ul>
            <li>Апстракција = Скривање на комплексни детали, прикажување на едноставен интерфејс</li>
            <li>Имплементирано преку апстрактни класи (делумна апстракција) и интерфејси (чиста апстракција)</li>
            <li>Апстрактни класи: можат да имаат апстрактни (мора да се имплементираат) и конкретни (веќе имплементирани) методи</li>
            <li>Не може да се создадат објекти од апстрактни класи</li>
            <li>Наследничките класи мора да имплементираат сите апстрактни методи</li>
            <li>Бенефити: намалување на комплексност, повторна употреба, подобрено одржување, овозможува полиморфизам</li>
            <li>Реална аналогија: контрола на автомобил, TV далечински управувач</li>
            <li>Без апстракција: корисниците би морале да разберат сите детали = преоптоварени</li>
            <li>Апстракцијата овозможува: рамки, библиотеки, plugins, чиста архитектура</li>
        </ul>

        <div class="note-box">
            <h3>Следно: Интерфејси</h3>
            <p>Откако разбирате апстракција со апстрактни класи, следно е <strong>интерфејси</strong> - најчиста форма на апстракција која дефинира договори без никаква имплементација.</p>
        </div>

        <div class="navigation-buttons">
            <a href="@Url.Action("Polymorphism", "OOP")" class="btn btn-outline-primary ajax-link">← Полиморфизам</a>
            <a href="@Url.Action("Interfaces", "OOP")" class="btn btn-primary ajax-link">Интерфејси →</a>
        </div>
    </div>

<style>
    .container {
        max-width: 800px;
        padding: 20px;
        background-color: var(--bs-body-bg);
    }

    h1, h2, h3 {
        color: var(--bs-heading-color);
        margin-bottom: 15px;
    }

    h1 {
        border-bottom: 2px solid var(--bs-primary);
        padding-bottom: 10px;
    }

    p, li, code {
        color: var(--bs-body-color);
        line-height: 1.6;
    }

    .note-box {
        background-color: rgba(111, 66, 193, 0.1);
        border: 1px solid var(--bs-indigo);
        border-radius: 5px;
        padding: 15px;
        margin: 20px 0;
    }

    .code-container {
        margin: 25px 0;
        border: 1px solid var(--bs-border-color);
        border-radius: 5px;
        overflow: hidden;
        background-color: var(--code-bg);
    }

    .code-header {
        background-color: var(--code-header-bg);
        padding: 10px 15px;
        border-bottom: 1px solid var(--bs-border-color);
        font-family: 'SFMono-Regular', Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        font-size: 0.9rem;
        color: var(--bs-body-color);
    }

    .code-content {
        padding: 15px;
        overflow-x: auto;
    }

    pre {
        margin: 0;
        white-space: pre-wrap;
        background-color: transparent;
        font-family: 'SFMono-Regular', Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    .result-box {
        padding: 10px 15px;
        background-color: rgba(0, 123, 255, 0.1);
        border-top: 1px solid var(--bs-border-color);
        font-size: 0.95rem;
    }

    .navigation-buttons {
        display: flex;
        justify-content: space-between;
        margin-top: 30px;
    }

    .btn {
        padding: 8px 20px;
        border-radius: 4px;
        font-weight: 500;
        text-decoration: none;
    }

    .btn-primary {
        background-color: var(--bs-primary);
        border-color: var(--bs-primary);
        color: #fff;
    }

    .btn-outline-primary {
        color: var(--bs-primary);
        border-color: var(--bs-primary);
        background-color: transparent;
    }
</style>

<script>
    window.oopAbstraction = {
        abstractionSteps: [
            {
                code: `public abstract class PaymentProcessor
{
    // Abstract - children must implement
    public abstract bool Process(decimal amount);
    
    // Concrete - already implemented  
    public void PrintReceipt(decimal amount)
    {
        Console.WriteLine("Receipt for: $" + amount);
        Console.WriteLine("Date: " + DateTime.Now);
    }
    
    // Virtual - can be overridden
    public virtual string GetProcessorName()
    {
        return "Generic Payment Processor";
    }
}

// public class CreditCardProcessor : PaymentProcessor
// {
//     public override bool Process(decimal amount)
//     {
//         Console.WriteLine("Processing credit card: $" + amount);
//         return true;
//     }
// }

// PaymentProcessor processor = new CreditCardProcessor();
// processor.Process(100);
// processor.PrintReceipt(100);`,
                vars: `PaymentProcessor (Abstract Class):
- Process() method: ABSTRACT (no code, MUST be implemented)
- PrintReceipt() method: CONCRETE (has code, ready to use)
- GetProcessorName() method: VIRTUAL (has code, CAN be overridden)

Cannot create: new PaymentProcessor() ❌
Can inherit and use as base class.`,
                exp: "We define an abstract PaymentProcessor class. It has a mix of abstract (must implement), concrete (already implemented), and virtual (can override) methods. This is partial abstraction - some details are hidden, some are provided."
            },
            {
                code: `public abstract class PaymentProcessor
{
    // Abstract - children must implement
    public abstract bool Process(decimal amount);
    
    // Concrete - already implemented  
    public void PrintReceipt(decimal amount)
    {
        Console.WriteLine("Receipt for: $" + amount);
        Console.WriteLine("Date: " + DateTime.Now);
    }
    
    // Virtual - can be overridden
    public virtual string GetProcessorName()
    {
        return "Generic Payment Processor";
    }
}

public class CreditCardProcessor : PaymentProcessor
{
    public override bool Process(decimal amount)
    {
        Console.WriteLine("Processing credit card: $" + amount);
        return true;
    }
}

// PaymentProcessor processor = new CreditCardProcessor();
// processor.Process(100);
// processor.PrintReceipt(100);`,
                vars: `CreditCardProcessor (Concrete Class):
- Inherits from PaymentProcessor (: PaymentProcessor)
- MUST implement abstract Process() method ✅
- Gets PrintReceipt() for FREE (from parent)
- Gets GetProcessorName() for FREE (can override)

Now we CAN create: new CreditCardProcessor() ✅`,
                exp: "CreditCardProcessor inherits from PaymentProcessor. It MUST implement the abstract Process() method (that's the contract). It automatically gets PrintReceipt() and GetProcessorName() methods from the parent class for free!"
            },
            {
                code: `public abstract class PaymentProcessor
{
    // Abstract - children must implement
    public abstract bool Process(decimal amount);
    
    // Concrete - already implemented  
    public void PrintReceipt(decimal amount)
    {
        Console.WriteLine("Receipt for: $" + amount);
        Console.WriteLine("Date: " + DateTime.Now);
    }
    
    // Virtual - can be overridden
    public virtual string GetProcessorName()
    {
        return "Generic Payment Processor";
    }
}

public class CreditCardProcessor : PaymentProcessor
{
    public override bool Process(decimal amount)
    {
        Console.WriteLine("Processing credit card: $" + amount);
        return true;
    }
}

PaymentProcessor processor = new CreditCardProcessor();
// processor.Process(100);
// processor.PrintReceipt(100);`,
                vars: `Variable created:
- Type: PaymentProcessor (abstract class type)
- Object: new CreditCardProcessor() (concrete object)

This is KEY abstraction: We use the abstract type to hide the concrete implementation.
Caller only knows PaymentProcessor interface, not CreditCardProcessor details.`,
                exp: "We create a PaymentProcessor variable but assign a CreditCardProcessor object. The variable type is abstract, hiding the concrete implementation. This is abstraction in action - hiding the 'how' (CreditCardProcessor) behind the 'what' (PaymentProcessor)."
            },
            {
                code: `public abstract class PaymentProcessor
{
    // Abstract - children must implement
    public abstract bool Process(decimal amount);
    
    // Concrete - already implemented  
    public void PrintReceipt(decimal amount)
    {
        Console.WriteLine("Receipt for: $" + amount);
        Console.WriteLine("Date: " + DateTime.Now);
    }
    
    // Virtual - can be overridden
    public virtual string GetProcessorName()
    {
        return "Generic Payment Processor";
    }
}

public class CreditCardProcessor : PaymentProcessor
{
    public override bool Process(decimal amount)
    {
        Console.WriteLine("Processing credit card: $" + amount);
        return true;
    }
}

PaymentProcessor processor = new CreditCardProcessor();
processor.Process(100);  // Calls CreditCardProcessor's implementation
// processor.PrintReceipt(100);`,
                vars: `Calling: processor.Process(100)
- processor is PaymentProcessor type
- PaymentProcessor has abstract Process() method
- Actual object is CreditCardProcessor
- Calls CreditCardProcessor.Process() implementation

Output: "Processing credit card: $100"

The abstract method is implemented by the concrete class.`,
                exp: "We call Process(100). Even though the variable is PaymentProcessor type, it calls CreditCardProcessor's implementation. The abstraction hides WHICH processor is used, but ensures Process() exists and works."
            },
            {
                code: `public abstract class PaymentProcessor
{
    // Abstract - children must implement
    public abstract bool Process(decimal amount);
    
    // Concrete - already implemented  
    public void PrintReceipt(decimal amount)
    {
        Console.WriteLine("Receipt for: $" + amount);
        Console.WriteLine("Date: " + DateTime.Now);
    }
    
    // Virtual - can be overridden
    public virtual string GetProcessorName()
    {
        return "Generic Payment Processor";
    }
}

public class CreditCardProcessor : PaymentProcessor
{
    public override bool Process(decimal amount)
    {
        Console.WriteLine("Processing credit card: $" + amount);
        return true;
    }
}

PaymentProcessor processor = new CreditCardProcessor();
processor.Process(100);
processor.PrintReceipt(100);  // Uses parent's implementation`,
                vars: `Calling: processor.PrintReceipt(100)
- PrintReceipt() is CONCRETE in PaymentProcessor
- CreditCardProcessor didn't override it
- Uses PaymentProcessor.PrintReceipt() implementation

Output:
"Receipt for: $100"
"Date: [current date/time]"

The concrete method from abstract class works without child implementation.`,
                exp: "We call PrintReceipt(100). This method is already implemented in the abstract PaymentProcessor class. CreditCardProcessor gets it for free! This shows abstraction's power: common code in abstract class, specific behavior in child classes."
            }
        ],

        simpleExamples: {
            example1: `// Abstract class: Defines what shapes ARE, some HOW
public abstract class Shape
{
    // Abstract method - MUST be implemented by children
    public abstract double CalculateArea();
    
    // Abstract method - MUST be implemented
    public abstract double CalculatePerimeter();
    
    // Concrete method - ALREADY implemented here
    public void DisplayInfo()
    {
        Console.WriteLine("Shape Type: " + GetType().Name);
        Console.WriteLine("Area: " + CalculateArea());
        Console.WriteLine("Perimeter: " + CalculatePerimeter());
    }
}

// Concrete class: Circle implements Shape
public class Circle : Shape
{
    public double Radius;
    
    // MUST implement abstract methods
    public override double CalculateArea()
    {
        return Math.PI * Radius * Radius;
    }
    
    public override double CalculatePerimeter()
    {
        return 2 * Math.PI * Radius;
    }
}

// Concrete class: Rectangle implements Shape
public class Rectangle : Shape
{
    public double Width;
    public double Height;
    
    // MUST implement abstract methods
    public override double CalculateArea()
    {
        return Width * Height;
    }
    
    public override double CalculatePerimeter()
    {
        return 2 * (Width + Height);
    }
}`
        },

        completeExamples: {
            example1: `// Abstract class: Defines what shapes ARE, some HOW
public abstract class Shape
{
    // Abstract method - MUST be implemented by children
    public abstract double CalculateArea();
    
    // Abstract method - MUST be implemented
    public abstract double CalculatePerimeter();
    
    // Concrete method - ALREADY implemented here
    public void DisplayInfo()
    {
        Console.WriteLine("Shape Type: " + GetType().Name);
        Console.WriteLine("Area: " + CalculateArea());
        Console.WriteLine("Perimeter: " + CalculatePerimeter());
        Console.WriteLine("---");
    }
    
    // Another concrete method
    public virtual string GetDescription()
    {
        return "This is a geometric shape.";
    }
}

// Concrete class: Circle implements Shape
public class Circle : Shape
{
    public double Radius;
    
    // MUST implement abstract methods
    public override double CalculateArea()
    {
        return Math.PI * Radius * Radius;
    }
    
    public override double CalculatePerimeter()
    {
        return 2 * Math.PI * Radius;
    }
    
    // CAN override virtual method (optional)
    public override string GetDescription()
    {
        return "A circle with radius " + Radius;
    }
}

// Concrete class: Rectangle implements Shape
public class Rectangle : Shape
{
    public double Width;
    public double Height;
    
    // MUST implement abstract methods
    public override double CalculateArea()
    {
        return Width * Height;
    }
    
    public override double CalculatePerimeter()
    {
        return 2 * (Width + Height);
    }
    
    // Uses default GetDescription() from Shape
}

// Concrete class: Triangle implements Shape
public class Triangle : Shape
{
    public double Base;
    public double Height;
    public double SideA;
    public double SideB;
    public double SideC;
    
    public override double CalculateArea()
    {
        return 0.5 * Base * Height;
    }
    
    public override double CalculatePerimeter()
    {
        return SideA + SideB + SideC;
    }
    
    public override string GetDescription()
    {
        return "A triangle with base " + Base + " and height " + Height;
    }
}

// Using the abstraction
Console.WriteLine("=== Shape Calculations ===");

// Can't create Shape directly: ❌ Shape s = new Shape();
// But can store children in Shape variables

Shape circle = new Circle() { Radius = 5 };
Shape rectangle = new Rectangle() { Width = 4, Height = 6 };
Shape triangle = new Triangle() { Base = 3, Height = 4, SideA = 3, SideB = 4, SideC = 5 };

// Same method calls, different implementations
circle.DisplayInfo();      // Uses Circle's CalculateArea/Perimeter
rectangle.DisplayInfo();   // Uses Rectangle's CalculateArea/Perimeter  
triangle.DisplayInfo();    // Uses Triangle's CalculateArea/Perimeter

// All shapes have GetDescription() from Shape class
Console.WriteLine("Descriptions:");
Console.WriteLine(circle.GetDescription());
Console.WriteLine(rectangle.GetDescription());  // Uses Shape's version
Console.WriteLine(triangle.GetDescription());`
        },

        currentStep: 0,

        convertCode: function(id) {
            const toggle = document.getElementById(id + "Toggle");
            const isComplete = toggle ? toggle.checked : false;
            const codeBlock = document.getElementById(id + "Code");
            const resultBox = document.getElementById(id + "Result");

            if (codeBlock && toggle) {
                codeBlock.style.transition = 'opacity 0.3s ease';
                codeBlock.style.opacity = '0.5';
                setTimeout(() => {
                    codeBlock.textContent = isComplete ? this.completeExamples[id] : this.simpleExamples[id];
                    codeBlock.style.opacity = '1';

                    if (resultBox && id === 'example1') {
                        resultBox.innerHTML = isComplete ? 
                            ' <strong>Output:</strong><br>=== Shape Calculations ===<br>Shape Type: Circle<br>Area: 78.53981633974483<br>Perimeter: 31.41592653589793<br>---<br>Shape Type: Rectangle<br>Area: 24<br>Perimeter: 20<br>---<br>Shape Type: Triangle<br>Area: 6<br>Perimeter: 12<br>---<br><br>Descriptions:<br>A circle with radius 5<br>This is a geometric shape.<br>A triangle with base 3 and height 4<br><br><em>Abstraction in Action:</em> The Shape class hides HOW area/perimeter are calculated. Circle, Rectangle, Triangle each implement their own formulas. Users just call CalculateArea() without knowing the math behind it!' :
                            ' <strong>Code Structure:</strong><br>Abstract Shape class with CalculateArea() and CalculatePerimeter() methods.<br>Circle class implements Shape with circle formulas (πr²).<br>Rectangle class implements Shape with rectangle formulas (w×h).<br>All shapes share DisplayInfo() method from Shape class.<br><br><em>Toggle to see the complete example with Triangle and descriptions!</em>';
                    }
                }, 300);
            }
        },

        updateWalkthrough: function(step) {
            const walkthroughCodeBase = document.getElementById('walkthroughCodeBase');
            const walkthroughVariables = document.getElementById('walkthroughVariables');
            const walkthroughExplanation = document.getElementById('walkthroughExplanation');
            const nextStepBtn = document.getElementById('nextStepBtn');

            if (!walkthroughCodeBase || !walkthroughVariables || !walkthroughExplanation) return;

            const data = this.abstractionSteps[step];
            
            walkthroughCodeBase.textContent = data.code;
            walkthroughVariables.textContent = data.vars;
            walkthroughExplanation.innerHTML = `<em>Step ${step + 1}:</em> ${data.exp}`;
            
            if (step === this.abstractionSteps.length - 1 && nextStepBtn) {
                walkthroughExplanation.innerHTML += '<br><strong> Complete! Abstraction hides implementation details behind a simple interface.</strong>';
                nextStepBtn.disabled = true;
            }
        },

        nextStep: function() {
            if (this.currentStep < this.abstractionSteps.length) {
                this.updateWalkthrough(this.currentStep);
                this.currentStep++;
            }
        },

        initWalkthrough: function() {
            const nextStepBtn = document.getElementById('nextStepBtn');
            if (nextStepBtn) {
                this.currentStep = 0;

                const newButton = nextStepBtn.cloneNode(true);
                nextStepBtn.parentNode.replaceChild(newButton, nextStepBtn);
                
                newButton.addEventListener('click', () => this.nextStep());
                newButton.disabled = false;
                
                this.updateWalkthrough(0);
                this.currentStep = 1;
            }
        },

        initCodeExamples: function() {
            const toggles = document.querySelectorAll('.form-check-input[type="checkbox"]');
            toggles.forEach(toggle => {
                const id = toggle.id.replace('Toggle', '');
                if (id && this.simpleExamples[id]) {
                    this.convertCode(id);
                    toggle.addEventListener('change', () => this.convertCode(id));
                }
            });
        },

        init: function() {
            console.log('Initializing OOP Abstraction page');
            this.initCodeExamples();
            this.initWalkthrough();

            if (typeof hljs !== 'undefined') {
                hljs.highlightAll();
            }
        }
    };

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
            window.oopAbstraction.init();
        });
    } else {
        window.oopAbstraction.init();
    }
</script>
</body>